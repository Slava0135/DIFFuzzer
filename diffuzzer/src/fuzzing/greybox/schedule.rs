use super::seed::Seed;

pub trait Scheduler {
    fn choose(&self, corpus: &[Seed]) -> Seed {
        todo!()
    }
}

/// Implemented by most greybox fuzzers.
/// Next seed is being chosen from the circular queue.
pub struct QueueScheduler {}

impl QueueScheduler {
    pub fn new() -> Self {
        Self {}
    }
}

impl Scheduler for QueueScheduler {}

/// Based on paper "Coverage-based Greybox Fuzzing as Markov Chain"
///
/// <https://mboehme.github.io/paper/CCS16.pdf>
///
/// A power schedule regulates the energy p(i) of a state.
/// More specifically, a power schedule decides how many inputs
/// are generated by fuzzing the seed ti ∈ T which exercises path i when ti is selected next.
///
/// In general, p(i) is a function of
///   - the number of times s(i) that ti has previously been choosen from the queue
///   - the number of generated inputs f(i) that exercise i. In fact, f(i) serves as approximation of the distribution’s density.
///
/// Exponential schedule (FAST) was proven to be the most effective:
/// `p(i) = min((α(i) / β) * (2^s(i) / f(i)), M)`, where
///   - α(i) can depend on the execution time, block transition coverage, and creation time of ti. (AFL)
///   - β > 1 is a constant
///   - f(i) is the amount of fuzz that exercises path i
///   - s(i) is the number of times that ti has previously been choosen from the queue
///
pub struct FastPowerScheduler {}

impl FastPowerScheduler {
    pub fn new() -> Self {
        Self {}
    }
}

impl Scheduler for FastPowerScheduler {}
