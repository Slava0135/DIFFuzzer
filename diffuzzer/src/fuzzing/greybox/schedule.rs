/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

use anyhow::Context;
use rand::{SeedableRng, rngs::StdRng, seq::SliceRandom};

use crate::abstract_fs::workload::Workload;

use super::{
    feedback::{CoverageMap, InputCoverage},
    seed::Seed,
};

pub trait Scheduler {
    fn choose(
        &mut self,
        corpus: &mut [Seed],
        fst_coverage_map: &CoverageMap,
        snd_coverage_map: &CoverageMap,
    ) -> anyhow::Result<Workload>;
}

/// Implemented by most greybox fuzzers.
/// Next seed is being chosen from the circular queue.
pub struct QueueScheduler {
    next_index: usize,
}

impl QueueScheduler {
    pub fn new() -> Self {
        Self { next_index: 0 }
    }
}

impl Scheduler for QueueScheduler {
    fn choose(
        &mut self,
        corpus: &mut [Seed],
        _fst_coverage_map: &CoverageMap,
        _snd_coverage_map: &CoverageMap,
    ) -> anyhow::Result<Workload> {
        if self.next_index >= corpus.len() {
            self.next_index = 0
        }
        let next = corpus
            .get_mut(self.next_index)
            .with_context(|| "failed to choose seed")?;
        next.times_choosen += 1;
        self.next_index += 1;
        Ok(next.workload.clone())
    }
}

/// Based on paper "Coverage-based Greybox Fuzzing as Markov Chain"
///
/// <https://mboehme.github.io/paper/CCS16.pdf>
///
/// A power schedule regulates the energy p(i) of a state.
/// More specifically, a power schedule decides how many inputs
/// are generated by fuzzing the seed ti ∈ T which exercises path i when ti is selected next.
///
/// In general, p(i) is a function of
///   - the number of times s(i) that ti has previously been choosen from the queue
///   - the number of generated inputs f(i) that exercise i. In fact, f(i) serves as approximation of the distribution’s density.
///
/// A more efficient coverage-based greybox fuzzer discovers an undiscovered state
/// in a low-density region while assigning the __least amount of total energy__.
///
/// Exponential schedule (FAST) was proven to be the most effective:
/// `p(i) = min((α(i) / β) * (2^s(i) / f(i)), M)`, where
///   - α(i) can depend on the execution time, block transition coverage, and creation time of ti. (AFL)
///   - β > 1 is a constant
///   - f(i) is the amount of fuzz that exercises path i
///   - s(i) is the number of times that ti has previously been choosen from the queue
///
pub struct FastPowerScheduler {
    rng: StdRng,
    m: f64,
}

impl FastPowerScheduler {
    pub fn new(m: u64) -> Self {
        Self {
            rng: StdRng::from_entropy(),
            m: m as f64,
        }
    }
}

impl Scheduler for FastPowerScheduler {
    fn choose(
        &mut self,
        corpus: &mut [Seed],
        fst_coverage_map: &CoverageMap,
        snd_coverage_map: &CoverageMap,
    ) -> anyhow::Result<Workload> {
        let next = corpus
            .choose_weighted_mut(&mut self.rng, |seed| {
                let fst_power = power(
                    seed.times_choosen,
                    &seed.fst_coverage,
                    fst_coverage_map,
                    self.m,
                );
                let snd_power = power(
                    seed.times_choosen,
                    &seed.snd_coverage,
                    snd_coverage_map,
                    self.m,
                );
                let power = if fst_power < snd_power {
                    fst_power
                } else {
                    snd_power
                };
                1.0 / power
            })
            .with_context(|| "failed to choose seed")?;
        next.times_choosen += 1;
        Ok(next.workload.clone())
    }
}

fn power(times_choosen: u64, coverage: &InputCoverage, coverage_map: &CoverageMap, m: f64) -> f64 {
    let base: f64 = 2.0;
    let p = base.powf(times_choosen as f64) / path_frequency(coverage, coverage_map) as f64;
    if p < m { p } else { m }
}

/// In original paper paths are considered equal only if coverage is exactly the same.
///
/// Instead of finding path frequency, try to find least frequent address of the path.
///
/// TODO: does this actually work?
fn path_frequency(coverage: &InputCoverage, coverage_map: &CoverageMap) -> u64 {
    *coverage
        .iter()
        .map(|addr| coverage_map.get(addr).unwrap_or(&1))
        .min()
        .unwrap_or(&1)
}
