use std::collections::{HashMap, HashSet};

use anyhow::Context;
use rand::{SeedableRng, rngs::StdRng, seq::SliceRandom};

use crate::abstract_fs::workload::Workload;

use super::seed::Seed;

pub trait Scheduler {
    fn choose(&mut self, corpus: &mut [Seed]) -> anyhow::Result<Workload>;
}

/// Implemented by most greybox fuzzers.
/// Next seed is being chosen from the circular queue.
pub struct QueueScheduler {
    next_index: usize,
}

impl QueueScheduler {
    pub fn new() -> Self {
        Self { next_index: 0 }
    }
}

impl Scheduler for QueueScheduler {
    fn choose(&mut self, corpus: &mut [Seed]) -> anyhow::Result<Workload> {
        if self.next_index >= corpus.len() {
            self.next_index = 0
        }
        let next = corpus
            .get_mut(self.next_index)
            .with_context(|| "failed to choose seed")?;
        next.times_choosen += 1;
        self.next_index += 1;
        Ok(next.workload.clone())
    }
}

/// Based on paper "Coverage-based Greybox Fuzzing as Markov Chain"
///
/// <https://mboehme.github.io/paper/CCS16.pdf>
///
/// A power schedule regulates the energy p(i) of a state.
/// More specifically, a power schedule decides how many inputs
/// are generated by fuzzing the seed ti ∈ T which exercises path i when ti is selected next.
///
/// In general, p(i) is a function of
///   - the number of times s(i) that ti has previously been choosen from the queue
///   - the number of generated inputs f(i) that exercise i. In fact, f(i) serves as approximation of the distribution’s density.
///
/// Exponential schedule (FAST) was proven to be the most effective:
/// `p(i) = min((α(i) / β) * (2^s(i) / f(i)), M)`, where
///   - α(i) can depend on the execution time, block transition coverage, and creation time of ti. (AFL)
///   - β > 1 is a constant
///   - f(i) is the amount of fuzz that exercises path i
///   - s(i) is the number of times that ti has previously been choosen from the queue
///
pub struct FastPowerScheduler {
    rng: StdRng,
}

impl FastPowerScheduler {
    pub fn new() -> Self {
        Self {
            rng: StdRng::from_entropy(),
        }
    }
}

impl Scheduler for FastPowerScheduler {
    fn choose(&mut self, corpus: &mut [Seed]) -> anyhow::Result<Workload> {
        let mut freq = HashMap::<u64, u64>::new();
        for seed in corpus.iter() {
            for k in &seed.coverage {
                let v = freq.get(k).unwrap_or(&0);
                freq.insert(*k, v + 1);
            }
        }
        let base: f64 = 2.0;
        let next = corpus
            .choose_weighted_mut(&mut self.rng, |seed| {
                base.powf(seed.times_choosen as f64) / path_frequency(&seed.coverage, &freq)
            })
            .with_context(|| "failed to choose seed")?;
        next.times_choosen += 1;
        Ok(next.workload.clone())
    }
}

/// In original paper paths are equal only if
fn path_frequency(coverage: &HashSet<u64>, freq: &HashMap<u64, u64>) -> f64 {
    let mut f: f64 = 1.0;
    for k in coverage {
        let v = freq.get(k).unwrap_or(&1);
        let v = *v as f64;
        f += v.log2();
    }
    f
}
